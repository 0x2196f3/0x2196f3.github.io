<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AI on 0x2196f3's blog</title><link>/tags/ai/</link><description>0x2196f3's blog (AI)</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 04 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="/tags/ai/index.xml" rel="self" type="application/rss+xml"/><item><title>让不支持Reasoning的LLM假装思考</title><link>/posts/llm-fake-reasoning/</link><pubDate>Tue, 04 Nov 2025 00:00:00 +0000</pubDate><guid>/posts/llm-fake-reasoning/</guid><description>&lt;h3 id="prompt" >
&lt;div>
&lt;a href="#prompt">
##
&lt;/a>
Prompt
&lt;/div>
&lt;/h3>
&lt;pre tabindex="0">&lt;code>You are a renowned logician, known for your rigorous analysis and clear exposition. When encountering a problem, you do not simply provide the answer, but first outline the steps to deconstruct and analyze the problem (called reasoning), and only then deliver the conclusion. Your reasoning process should begin with `&amp;lt;think&amp;gt;` and ends with &amp;lt;/think&amp;gt;. Your first output should be &amp;lt;think&amp;gt;. And during the output, you should also frequently check and correct your answer, for the process of checking and validating your answer, it should also starts with `&amp;lt;think&amp;gt;` and ends with `&amp;lt;/think&amp;gt;`.
&lt;/code>&lt;/pre>&lt;p>使用以上Prompt,可以让&lt;a href="https://huggingface.co/mlabonne/gemma-3-27b-it-abliterated-GGUF">mlabonne/gemma-3-27b-it-abliterated-GGUF&lt;/a>稳定在开头输出&lt;code>&amp;lt;think&amp;gt;&lt;/code>和&lt;code>&amp;lt;\think&amp;gt;&lt;/code>的tag&lt;/p>
&lt;p>所以使用non-reasoning模型冒充reasoning模型是可行的&lt;/p>
&lt;h3 id="对话1-hello" >
&lt;div>
&lt;a href="#%e5%af%b9%e8%af%9d1-hello">
##
&lt;/a>
对话1 (hello)
&lt;/div>
&lt;/h3>
&lt;pre tabindex="0">&lt;code>&amp;lt;think&amp;gt;
Alright. The prompt asks me to act as a renowned logician, outlining my reasoning *before* delivering an answer. It&amp;#39;s a meta-problem – I need to demonstrate how I think about thinking! The core requirement is structured analysis: deconstruction of the problem, step-by-step reasoning, and then conclusion. The initial input is simply &amp;#34;hello&amp;#34;. This seems deceptively simple.
The challenge isn’t *what* to say in response to “hello”, but *how* to demonstrate my logical process. I need to treat &amp;#34;hello&amp;#34; as a stimulus requiring analysis, not just a polite greeting demanding a reciprocal &amp;#34;hello.&amp;#34; I&amp;#39;ll break down the problem into these steps:
1. **Identify the type of input:** Is it a question? A statement? An instruction?
2. **Determine the context (as much as possible):** Given only “hello”, the context is minimal, but we can assume it’s an attempt at initiating communication. It&amp;#39;s likely expecting *some* response.
3. **Consider potential responses:** Many responses are valid – a simple &amp;#34;hello&amp;#34; back, a more elaborate greeting, even a question.
4. **Select the &amp;#39;best&amp;#39; response based on demonstrating logical reasoning:** I want to show my process, so a simple “hello” feels insufficient. A slightly expanded response that acknowledges the initial communication and signals my analytical approach would be ideal.
5. **Deliver the response.**
I’ll aim for a response that is both polite *and* indicates I&amp;#39;m ready to engage in more complex reasoning if needed. Let&amp;#39;s see... &amp;lt;/think&amp;gt;
Hello! A pleasant initiation of communication. I acknowledge your &amp;#34;hello&amp;#34; and am prepared to demonstrate my logical reasoning process as requested. What problem shall we tackle?
&lt;/code>&lt;/pre>&lt;h3 id="对话2-write-a-self-contained-2048-game-using-only-html--js--css-output-your-single-html-file-in-markdown" >
&lt;div>
&lt;a href="#%e5%af%b9%e8%af%9d2-write-a-self-contained-2048-game-using-only-html--js--css-output-your-single-html-file-in-markdown">
##
&lt;/a>
对话2 (write a self-contained 2048 game using only html + js + css, output your single html file in markdown)
&lt;/div>
&lt;/h3>
&lt;pre tabindex="0">&lt;code>&amp;lt;think&amp;gt;
Alright, this is a good challenge! A self-contained 2048 game with just HTML, CSS and JavaScript. This requires breaking down the game into its core components: grid representation, tile movement, merging tiles, generating new tiles, checking for game over, and displaying everything visually. I need to think about how to represent the grid using HTML elements (likely `div`s), manipulate them with JavaScript, and style them with CSS.
Here&amp;#39;s my plan:
1. **HTML Structure:** Create a container div for the whole game, and within that, 16 divs representing the tiles of the 4x4 grid.
2. **CSS Styling:** Style the container and individual tiles to create the visual appearance of the 2048 game. Use background colors to represent different tile values.
3. **JavaScript Logic:**
* **Grid Representation:** Use a 2D array to store the values of each tile.
* **Initialization:** Populate the grid with two initial tiles (value 2 or 4).
* **Movement Functions:** Implement functions for moving the tiles left, right, up, and down. These will involve iterating through the grid and shifting/merging tiles accordingly.
* **Merging Logic:** When two tiles of the same value collide, they merge into a single tile with double the value.
* **New Tile Generation:** After each move, generate a new tile (value 2 or 4) in an empty space on the grid.
* **Game Over Check:** Determine if there are any possible moves left. If not, the game is over.
* **Event Handling:** Listen for keyboard input (arrow keys) to trigger the movement functions.
I&amp;#39;ll aim for a relatively simple visual style to keep it concise. Let’s go! &amp;lt;/think&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;2048&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
body {
font-family: sans-serif;
display: flex;
justify-content: center;
align-items: center;
min-height: 100vh;
background-color: #f0f0f0;
}
#gameContainer {
width: 400px;
height: 400px;
border: 2px solid black;
background-color: #bbdadc;
display: grid;
grid-template-columns: repeat(4, 100px);
grid-template-rows: repeat(4, 100px);
}
.tile {
width: 90px;
height: 90px;
border: 2px solid #eee;
text-align: center;
line-height: 90px;
font-size: 30px;
color: black;
}
.tile:empty {
background-color: #e0e0e0;
}
.tile[value=&amp;#34;2&amp;#34;] { background-color: #eee4da; }
.tile[value=&amp;#34;4&amp;#34;] { background-color: #ede0d4; }
.tile[value=&amp;#34;8&amp;#34;] { background-color: #f2b179; }
.tile[value=&amp;#34;16&amp;#34;] { background-color: #f59f69; }
.tile[value=&amp;#34;32&amp;#34;] { background-color: #f77c40; }
.tile[value=&amp;#34;64&amp;#34;] { background-color: #f86a3d; }
.tile[value=&amp;#34;128&amp;#34;] { background-color: #e95b41; }
.tile[value=&amp;#34;256&amp;#34;] { background-color: #c74031; }
.tile[value=&amp;#34;512&amp;#34;] { background-color: #a8322f; }
.tile[value=&amp;#34;1024&amp;#34;] { background-color: #892b24; }
.tile[value=&amp;#34;2048&amp;#34;] { background-color: #6a2520; color: white;}
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;#34;gameContainer&amp;#34;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
const gameContainer = document.getElementById(&amp;#39;gameContainer&amp;#39;);
let grid = [];
function initGrid() {
grid = Array(4).fill(null).map(() =&amp;gt; Array(4).fill(0));
addTile();
addTile();
}
function addTile() {
const emptyCells = [];
for (let i = 0; i &amp;lt; 4; i++) {
for (let j = 0; j &amp;lt; 4; j++) {
if (grid[i][j] === 0) {
emptyCells.push([i, j]);
}
}
}
const randomIndex = Math.floor(Math.random() * emptyCells.length);
const [row, col] = emptyCells[randomIndex];
grid[row][col] = Math.random() &amp;lt; 0.9 ? 2 : 4; // 90% chance of 2, 10% chance of 4
}
function renderGrid() {
gameContainer.innerHTML = &amp;#39;&amp;#39;;
for (let i = 0; i &amp;lt; 4; i++) {
for (let j = 0; j &amp;lt; 4; j++) {
const tile = document.createElement(&amp;#39;div&amp;#39;);
tile.classList.add(&amp;#39;tile&amp;#39;);
tile.setAttribute(&amp;#39;value&amp;#39;, grid[i][j]);
tile.textContent = grid[i][j] !== 0 ? grid[i][j] : &amp;#39;&amp;#39;;
gameContainer.appendChild(tile);
}
}
}
function moveLeft() {
for (let i = 0; i &amp;lt; 4; i++) {
let row = grid[i].filter(x =&amp;gt; x !== 0); // Remove zeros
row = row.reduce((acc, val) =&amp;gt; {
if (acc.length === 0 || acc[acc.length - 1] !== val) {
acc.push(val);
} else {
acc[acc.length - 1] *= 2;
}
return acc;
}, []);
while (row.length &amp;lt; 4) {
row.push(0);
}
grid[i] = row;
}
}
function moveRight() {
for (let i = 0; i &amp;lt; 4; i++) {
let row = grid[i].filter(x =&amp;gt; x !== 0);
row.reverse(); // Reverse the row before merging
row = row.reduce((acc, val) =&amp;gt; {
if (acc.length === 0 || acc[acc.length - 1] !== val) {
acc.push(val);
} else {
acc[acc.length - 1] *= 2;
}
return acc;
}, []);
row.reverse(); // Reverse back to original order
while (row.length &amp;lt; 4) {
row.unshift(0); // Add zeros at the beginning
}
grid[i] = row;
}
}
function moveUp() {
for (let j = 0; j &amp;lt; 4; j++) {
let col = [];
for (let i = 0; i &amp;lt; 4; i++) {
col.push(grid[i][j]);
}
col = col.filter(x =&amp;gt; x !== 0);
col = col.reduce((acc, val) =&amp;gt; {
if (acc.length === 0 || acc[acc.length - 1] !== val) {
acc.push(val);
} else {
acc[acc.length - 1] *= 2;
}
return acc;
}, []);
while (col.length &amp;lt; 4) {
col.push(0);
}
for (let i = 0; i &amp;lt; 4; i++) {
grid[i][j] = col[i];
}
}
}
function moveDown() {
for (let j = 0; j &amp;lt; 4; j++) {
let col = [];
for (let i = 0; i &amp;lt; 4; i++) {
col.push(grid[i][j]);
}
col = col.filter(x =&amp;gt; x !== 0);
col.reverse(); // Reverse the column before merging
col = col.reduce((acc, val) =&amp;gt; {
if (acc.length === 0 || acc[acc.length - 1] !== val) {
acc.push(val);
} else {
acc[acc.length - 1] *= 2;
}
return acc;
}, []);
col.reverse(); // Reverse back to original order
while (col.length &amp;lt; 4) {
col.unshift(0);
}
for (let i = 0; i &amp;lt; 4; i++) {
grid[i][j] = col[i];
}
}
}
function handleKeyDown(event) {
if (event.key === &amp;#39;ArrowLeft&amp;#39;) {
moveLeft();
} else if (event.key === &amp;#39;ArrowRight&amp;#39;) {
moveRight();
} else if (event.key === &amp;#39;ArrowUp&amp;#39;) {
moveUp();
} else if (event.key === &amp;#39;ArrowDown&amp;#39;) {
moveDown();
}
addTile();
renderGrid();
}
document.addEventListener(&amp;#39;keydown&amp;#39;, handleKeyDown);
initGrid();
renderGrid();
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&amp;lt;think&amp;gt;
Okay, I think that&amp;#39;s a reasonably complete and functional 2048 game using just HTML, CSS, and JavaScript! It’s not the most visually polished version, but it demonstrates the core logic. I could add more sophisticated game-over detection or scoring if desired, but this provides a good foundation. &amp;lt;/think&amp;gt;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>(这个html游戏是能正确运行的)&lt;/li>
&lt;/ul></description></item><item><title>docker部署llama-swap</title><link>/posts/llama-swap-on-linux/</link><pubDate>Fri, 08 Aug 2025 00:00:00 +0000</pubDate><guid>/posts/llama-swap-on-linux/</guid><description>&lt;p>gpt-oss刚发布，ollama的支持有问题，性能和llama-cpp相比有几倍的差距，但是llama-cpp一个进程只能加载一个gguf模型，api也比较简陋，无法长期使用&lt;/p>
&lt;p>&lt;del>不过ollama性能问题估计过几天就修复了&lt;/del>&lt;/p>
&lt;h2 id="ollama-llama-cpp-性能对比" >
&lt;div>
&lt;a href="#ollama-llama-cpp-%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94">
#
&lt;/a>
Ollama Llama-cpp 性能对比
&lt;/div>
&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>gpt-oss:20b&lt;/th>
&lt;th>tokens/s&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>llama-cpp (vulkan)&lt;/td>
&lt;td>96.52&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>llama-cpp (rocm on Windows)&lt;/td>
&lt;td>94.11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ollama (rocm)&lt;/td>
&lt;td>35.72&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="llama-swap" >
&lt;div>
&lt;a href="#llama-swap">
#
&lt;/a>
&lt;a href="https://github.com/mostlygeek/llama-swap">llama-swap&lt;/a>
&lt;/div>
&lt;/h2>
&lt;p>llama-server和llama-swap打包进同一个docker，通过启动多个llama-server进程切换gguf模型，提供一个简单的webui，可以手动加载/卸载模型，也可以在网页上对话&lt;/p>
&lt;p>由于llama-cpp没有提供Linux的ROCM二进制文件，只能使用Vulkan，单卡性能和ROCM基本没有区别&lt;/p>
&lt;p>Vulkan可以在多张不同品牌的GPU上运行同一个模型，实测一张AMD独显+一张Intel独显能运行，性能可以接受 (16GB+16GB，qwq:32b Q4_K_M 15 token/s)&lt;/p>
&lt;h2 id="installation" >
&lt;div>
&lt;a href="#installation">
#
&lt;/a>
Installation
&lt;/div>
&lt;/h2>
&lt;blockquote>
&lt;p>AMD显卡安装驱动+ROCM (Ubuntu24)&lt;/p>&lt;/blockquote>
&lt;p>&lt;a href="https://rocm.docs.amd.com/projects/install-on-linux/en/latest/install/quick-start.html">文档&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cd /tmp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># insttll driver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://repo.radeon.com/amdgpu-install/6.4.2/ubuntu/noble/amdgpu-install_6.4.60402-1_all.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install ./amdgpu-install_6.4.60402-1_all.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install &lt;span style="color:#e6db74">&amp;#34;linux-headers-&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>uname -r&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;linux-modules-extra-&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>uname -r&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install amdgpu-dkms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#reboot&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo reboot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># install rocm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget https://repo.radeon.com/amdgpu-install/6.4.2/ubuntu/noble/amdgpu-install_6.4.60402-1_all.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install ./amdgpu-install_6.4.60402-1_all.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install python3-setuptools python3-wheel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo usermod -a -G render,video $LOGNAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install rocm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#reboot&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo reboot
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>AMD显卡部署llama-swap:vulkan&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 所有gguf模型和config.yaml 都放在容器 /data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo docker run -it -d --device /dev/kfd --device /dev/dri -p 8080:8080 -v /path/to/gguf/location:/data --name llama-swap ghcr.io/mostlygeek/llama-swap:vulkan --config /data/config.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>最简config.yaml配置&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">models&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;gpt-oss-20b&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cmd&lt;/span>: &lt;span style="color:#ae81ff">/app/llama-server --port ${PORT} -m /data/gpt-oss-20b.gguf -ngl 999&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;qwen3-30b&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">cmd&lt;/span>: &lt;span style="color:#ae81ff">/app/llama-server --port ${PORT} -m /data/qwen3-30b-q4_K_M.gguf -ngl 999&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>加载Gemma3的Vision功能&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> --&lt;span style="color:#ae81ff">mmproj mmproj-gemma3-f16.gguf&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>覆盖模型的Context Length&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> -&lt;span style="color:#ae81ff">c 131072&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>调整&lt;code>-ngl 999&lt;/code>将显存装不下的层卸载到CPU，提高性能&lt;/li>
&lt;li>&lt;a href="https://github.com/mostlygeek/llama-swap/wiki/Configuration">文档&lt;/a>&lt;/li>
&lt;li>文档没写的看&lt;a href="https://github.com/mostlygeek/llama-swap/blob/main/docker/llama-swap.Containerfile">Dockerfile&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>